// test/services/persistence_service_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart'; // For @GenerateMocks

import 'package:flashcard/services/persistence_service.dart';

// Import the generated mocks file (will be created by build_runner)
import 'persistence_service_test.mocks.dart';

// Annotation to generate a mock class for SharedPreferences
@GenerateMocks([SharedPreferences])
void main() {
  // Use MockSharedPreferences generated by build_runner
  late MockSharedPreferences mockPrefs;
  late PersistenceService persistenceService;

  // Sample data
  const int testCardId = 123;
  const String testKey = 'checklist_state_$testCardId'; // Manually create key for setting up mock
  final Map<int, bool> testChecklistState = {0: true, 1: false, 2: true};
  // Expected JSON string for the testChecklistState
  const String expectedJson = '{"0":true,"1":false,"2":true}';

  setUp(() {
    // Create a fresh mock for each test
    mockPrefs = MockSharedPreferences();
    // Inject the mock into the service
    persistenceService = PersistenceService(mockPrefs);

    // --- Default Mock Behavior (Optional but Recommended) ---
    // Define default behavior for methods that might be called but whose
    // return value isn't critical for a specific test, or to avoid null errors.
    // Example: when loading non-existent keys, return null.
    when(mockPrefs.getString(any)).thenReturn(null);
    when(mockPrefs.setString(any, any)).thenAnswer((_) async => true); // Mock successful save
    when(mockPrefs.remove(any)).thenAnswer((_) async => true); // Mock successful remove
  });

  group('PersistenceService Tests with Mocks', () {

    test('Save Checklist State - Success', () async {
      // Arrange: Configure the mock setString to expect the correct key and value
      // Return true to simulate success.
      when(mockPrefs.setString(testKey, expectedJson)).thenAnswer((_) async => true);

      // Act: Call the method to test
      await persistenceService.saveChecklistState(testCardId, testChecklistState);

      // Assert: Verify setString was called once with the expected arguments
      verify(mockPrefs.setString(testKey, expectedJson)).called(1);
    });

    test('Save Checklist State - Null ID', () async {
      // Act: Call with null ID
      await persistenceService.saveChecklistState(null, testChecklistState);

      // Assert: Verify no SharedPreferences methods were called
      verifyNever(mockPrefs.setString(any, any));
      verifyNever(mockPrefs.getString(any));
      verifyNever(mockPrefs.remove(any));
    });

    test('Load Checklist State - Found', () async {
      // Arrange: Configure the mock getString to return the expected JSON
      when(mockPrefs.getString(testKey)).thenReturn(expectedJson);

      // Act: Call the load method
      final loadedState = await persistenceService.loadChecklistState(testCardId);

      // Assert: Verify getString was called and the state is decoded correctly
      verify(mockPrefs.getString(testKey)).called(1);
      expect(loadedState, equals(testChecklistState));
    });

    test('Load Checklist State - Not Found', () async {
      // Arrange: Ensure getString returns null (handled by default mock behavior in setUp)
      // when(mockPrefs.getString(testKey)).thenReturn(null); // Explicitly if needed

      // Act: Call the load method
      final loadedState = await persistenceService.loadChecklistState(testCardId);

      // Assert: Verify getString was called and result is empty
      verify(mockPrefs.getString(testKey)).called(1);
      expect(loadedState, isEmpty);
    });

     test('Load Checklist State - Invalid JSON', () async {
       // Arrange: Configure mock to return invalid JSON
       when(mockPrefs.getString(testKey)).thenReturn('{invalid json');

       // Act
       final loadedState = await persistenceService.loadChecklistState(testCardId);

       // Assert: Verify getString was called, expect empty map due to parsing error handling
       verify(mockPrefs.getString(testKey)).called(1);
       expect(loadedState, isEmpty);
     });

     test('Load Checklist State - Malformed Data (Non-bool value)', () async {
       // Arrange: Configure mock to return valid JSON structure but wrong data type
       when(mockPrefs.getString(testKey)).thenReturn('{"0":true,"1":"not_a_bool"}');

       // Act
       final loadedState = await persistenceService.loadChecklistState(testCardId);

       // Assert: Verify getString was called, expect only valid items parsed
       verify(mockPrefs.getString(testKey)).called(1);
       expect(loadedState, equals({0: true}));
     });


    test('Load Checklist State - Null ID', () async {
      // Act: Call with null ID
      final loadedState = await persistenceService.loadChecklistState(null);

      // Assert: Verify no SharedPreferences methods were called and result is empty
      verifyNever(mockPrefs.getString(any));
      expect(loadedState, isEmpty);
    });

    test('Clear Checklist State - Success', () async {
      // Arrange: Configure mock remove to return true for success
      when(mockPrefs.remove(testKey)).thenAnswer((_) async => true);

      // Act: Call the clear method
      await persistenceService.clearChecklistState(testCardId);

      // Assert: Verify remove was called once with the correct key
      verify(mockPrefs.remove(testKey)).called(1);
    });

     test('Clear Checklist State - Null ID', () async {
      // Act: Call with null ID
      await persistenceService.clearChecklistState(null);

      // Assert: Verify remove was never called
      verifyNever(mockPrefs.remove(any));
    });

  });
}